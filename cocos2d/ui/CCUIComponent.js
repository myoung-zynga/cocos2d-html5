/****************************************************************************
 Copyright (c) 2013      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * The Component is the base class for all user interface objects.
 * It provides the default set of functionalities for input handling,
 * traversal, and painting.
 * 
 * Applications can register listeners for certain events (see a list below) 
 * generated by a Component. Listeners can be added and removed using the 
 * Component.addListener() and Component.removeListener() methods.
 * A listener may either implement the cc.ui.EventListener
 * interface, or be a function. The EventListener interface is intentionally
 * a flexible, generic interface to receive any type of event notification. 
 * Events themselves are defined as string identifiers. The 
 * EventListener.eventNotify() method (or the function) will be called with the 
 * event encountered, and a single details object containing the properties
 * of the event. The details object will have specific properties and be 
 * different for each event, however every details object will have a "src" 
 * property which refers to the Component on which the event occurred.
 * 
 * The Component events which listeners may register for are:
 * <ul>
 * <li>traverse : details.direction will contain the direction of
 * the traversal</li>
 * <li>focusChange : details.focus will contain the current focus state</li>
 * <li>keyPress : details.keyCode will contain the key's identifier code</li>
 * <li>keyRelease : details.keyCode will contain the key's identifier code</li>
 * <li>keyLongPress : details.keyCode will contain the key's identifier code</li>
 * <li>keyFired : details.keyCode will contain the key's identifier code</li>
 * <li>penPress : details.x and details.y contain the pen press location</li>
 * <li>penDrag : details.x and details.y contain the pen drag location</li>
 * <li>penRelease : details.x and details.y contain the pen release location</li> 
 * <li>penLongPress : details.x and details.y contain the pen long press
 * location</li>
 * <li>textInput : details.text contains the text received as input</li>
 * <li>swipeEvent : details.startX, details.startY, details.endX, details.endY 
 * contain swipe's start and end locations; details.duration and details.dir contain
 * swipe's duration and direction (which is one of cc.ui.Constants: 
 * TRVS_UP, TRVS_DOWN, TRVS_LEFT, TRVS_RIGHT); details.deltaX and details.deltaY
 * contain x, y deltas of the swipe </li>
 * </ul>
 * 
 * A Component can have border, padding, and margin around its content.
 * Instances of <a href="./cc.ui.Border.html">cc.ui.Border</a>
 * subclasses can be used as Component's border. 
 * By default Component's border is null.
 * When set border is placed along Component's edge.
 * <br><br>
 * In addition to a border Component can have padding and margin set around its
 * content. Both padding and margin are set to be 0 by default from each side
 * (from top, left, bottom and right). Both padding and margin could be uneven
 * from different sides (for example 0 on the top and 10 on the left). Padding is
 * located between border (if present) and Component's margin area. 
 * If a Component has background color or image set and padding is greater than 0,
 * Component does not fill its padding area with its background color or image.
 * Margin area is located between padding and Component's content. It is painted
 * with Component's background color or image (if either is set).
 * <br><br>
 * 
 * Note that when any property gets changed in Component,
 * automatic resize or repaint is not done. That is when a property
 * is changed on a Component or its subclass, the application is responsible
 * to call <a href="#a_sizeChanged">sizeChanged()</a>, 
 * <a href="#a_updateLayout">updateLayout()</a> or 
 * <a href="#a_repaint">repaint()</a> depending on the 
 * nature of the property changed.
 * 
 * Repaint() call repaints the Component without any re-layout. 
 * updateLayout() call relays out the Component based on its current size.
 * It should be called when only Component's internal layout changes.
 * sizeChanged() should be called when Component is expected to be granted 
 * a new size.
 */
cc.ui.Component = cc.Node.extend({
 
    $listeners : null,

    $focusable : false,
    $ownsFocus : false,
    $sawKey : -1,

    $touchEnabled : false,
    $pressed : false,
    $swipeEnabled : false,
    $penDown : null,
    $penDownTime : 0,

    $ibounds : null,

    $prefSize : null,
    $sizeDirty : true,
    $stretches : false,
    $clipsContent : false,
    $lazyImagesEnabled : false,

    $margin : null,
    $border : null,
    $padding : null,

    $hasOverlay : false,
    $isDirty : true,
    
    $hasBG : false,
    $background : null,

    $halign : cc.ui.Constants.ALGN_LEFT,
    $valign : cc.ui.Constants.ALGN_TOP,

    ctor:function () {
        this._super();

        this.$listeners = new Object();
        
        // Sizing & Clip
        // inner bounds of the Component, in the Component's coord space
        this.$ibounds = { "x" : 0, "y" : 0, "w" : 0, "h" : 0 };
        this.$prefSize = { "w" : -1, "h" : -1 };
         
        // Box Model
        this.$margin = { "t" : 0, "l" : 0, "b" : 0, "r" : 0 };
        this.$padding = { "t" : 0, "l" : 0, "b" : 0, "r" : 0 };
        
        // Background
        this.$background = new cc.ui.Background();
        // this.addChild(this.$background);

        this.setAnchorPoint(0, 0);
    },
    
   
    /**
     * Determine if this Component is a descendant of the given parent.
     * If this Component is at all nested within the given parent, 
     * this method will return true, false otherwise.
     * 
     * @param  parent the parent node in which to look for this component.
     * 
     * @return true if this Component is a descendant of the given parent 
     *              false otherwise. 
     */  
    isDescendant : function(parent) {
        try {
            var cont = null;
            var comp = this;
            while (comp != null) {
                cont = comp._parent;
                if (cont === parent) {
                    return true;
                }
                comp = cont;
            }
        } catch (err) {
            cc.ui.logW("cc.ui",
                       "isDecendant error: " + err);
        }
        return false;
    },
    
    /**
     * Convenience function to search up a Component's parent tree
     * and return the highest level parent which contains it, or null
     * if this Component has not yet been added to a parent.
     * 
     * @return the highest level parent which contains the Component, or
     *         null if the Component has not yet been added one.
     */
    getTopLevelContainer : function() {
        var p = this._parent;
        var q = null;
        while (p != null) {
            q = p._parent;
            if (q == null) {
                return p;
            }
            p = q;
        }
        return null;
    },
    
    /**
     * Get the focusable property of this Component, meaning that the
     * Component can be traversed to and is somehow interactive.
     *
     * @return true if the Component is interactive and should receive input 
     *              focus from the traversal subsystem
     */
    isFocusable : function() {
        return this.$focusable;
    },
    
    /**
     * Set the focusable property of this Component, meaning that the
     * Component can be traversed to and is somehow interactive. A Component
     * can only receive the input focus if it is both focusable and has its
     * visible state set to true. 
     *
     * Note that calling setFocusable(false) when this Component has focus
     * does not result in this Component loosing focus. Only when traversal out 
     * happens this Component becomes non-focusable. 
     *
     * @param onOff the focusable property of the Component
     */
    setFocusable : function(onOff) {
        this.$focusable = (onOff == true);
    },
    
    /**
     * Determine if this Component currently has the input focus.
     *
     * @return true if this Component currently has the input focus
     */
    hasFocus : function() {
        return this.$ownsFocus;
    },
    
    /**
     * Request that the input focus be transferred to this Component. Calling
     * this method will attempt to synchronously move the input focus from
     * whichever Component currently has it (if any) to this Component. In
     * order for this call to be successful, this Component must be both
     * focusable and visible, and the Component which currently has focus
     * (if any) must return false from its changeFocus() method. Any change
     * in focus will automatically trigger a repaint of this Component by
     * the FocusManager.
     * 
     * @return true if the focus was successfully transferred to this Component
     */
    requestFocus : function() {
        try {
            if (this.$focusable && this._visible && !this.$ownsFocus) {
                var tlc = this.getTopLevelContainer();
                if (tlc != null) {
                    return tlc.getFocusManager().setFocusOwner(this,
                                                 cc.ui.Constants.TRVS_FWD);
                }
            }
        } catch (err) {
            cc.ui.logE("cc.ui.Component", 
                       "requestFocus error: " + err);
        }
        return false;
    },

    /**
     * Notify this Component that the focus subsystem changes the
     * state of its focus after traversal in the specified direction.
     * The direction values are defined in cc.ui.Constants: 
     * TRVS_DOWN, TRVS_UP, TRVS_RIGHT, TRVS_LEFT, TRVS_FWD, or TRVS_BKWD.
     * 
     * When this Component has a change in focus, it will generate a 
     * "focusChange" event to registered listeners. The event parameter will 
     * have a "focusChange" property set to true or false, indicating the 
     * new focus state of the Component.
     * 
     * Note that this method should not be used to request a change in focus,
     * for that applications should use the requestFocus() method.
     *
     * @param onOff the new focus state of this Component 
     * @param dir the traversal direction that resulted in that focus change
     * @return true if the focus state of this Component is changed, false
     *              otherwise
     */
    changeFocus : function(onOff, dir) {
        var ret = false;
        if (typeof onOff == 'boolean' && this.$ownsFocus != onOff) {
            this.$ownsFocus = onOff;
            
            if (!this.$ownsFocus) {
                if (this.$pressed) {
                    this.$pressed = false;               
                }
                
                this.$penDown = null;
                this.$penDownTime = 0;
            }
            this.notifyListeners("focusChange", { "focus" : this.$ownsFocus } );
            ret = true;
        }
        return ret;
    },
    
    /**
     * Determine if this Component has touch support enabled. All Components
     * have the ability to handle touch support. If this Component has touch 
     * enabled (see setTouchEnabled()), then it will automatically process 
     * touch events and generate "pressed" events on touch. By default,
     * this value is false.
     * 
     * @return true if this Component has touch enabled
     */
    getTouchEnabled : function() {
        return this.$touchEnabled;
    },
    
    /**
     * Set whether this Component has touch support enabled. All Components
     * have the ability to handle touch support. If this Component has touch
     * enabled (see getTouchEnabled()), then it will automatically process 
     * touch events and generate "pressed" events on touch. By default,
     * this value is false.
     * 
     * @param onOff flag indicating whether this Component should process 
     *              touch events
     */
    setTouchEnabled : function(onOff) {
        this.$touchEnabled = (onOff == true);
    },
    
    /**
     * Determine if this Component is currently being "pressed". If this
     * Component is touch enabled (see setTouchEnabled()), this method will
     * return true if it is currently in a "pressed" state. The "pressed"
     * state is achieved by a pen press event. If the Component receives a pen
     * release event which is not interrupted by a pen drag or some other
     * errant condition, the Component will generate and send a "pressed" 
     * event to its registered listeners.
     * 
     * @return true if this Component is currently in a "pressed" state and
     *              is considered armed to generate a "fired" event
     */
    isPressed : function() {
        return this.$pressed;
    },
    
    /**
     * Return the preferred size of this Component as set using
     * the setPreferredSize() method. This method is not intended to be 
     * overridden by subclasses, and returns a preferred width and height
     * of -1 if no preferred size has been set.
     * 
     * @return the preferred size of this Component as the 
     *         object &#123 width : #, height : # &#125
     */
    getPreferredSize : function() {
        return { "width" : this.$prefSize.w, "height" : this.$prefSize.h };
    },
    
    /**
     * Called to manually set the preferred dimensions of this Component.
     * By setting the preferred size, the layout subsystem will use the
     * preferred size when calculating the size of the Component. In order to 
     * turn off this manual sizing and return to relying on the default sizing
     * method, set the preferred sizes to -1. The preferred size dimensions
     * should include the sizing necessary to include the Component's margin,
     * border, padding, and content.
     * 
     * @param prefWidth the preferred width for this Component, or -1 to
     *                  resume using the default size
     * @param prefHeight the preferred height for this Component, or -1 to
     *                   resume using the size
     */
    setPreferredSize : function(prefWidth, prefHeight) {
        if (typeof prefWidth == 'number' &&
            typeof prefHeight == 'number') 
        {
            this.$prefSize.w = prefWidth < 0 ? -1 : prefWidth;
            this.$prefSize.h = prefHeight < 0 ? -1 : prefHeight;
        }
    },
    
    /**
     * Determine if this Component should be stretched beyond its typical
     * preferred size to match the space available by the layout subsystem
     * (false by default). If set to true, this Component will be stretched 
     * to match the maximum available size from its parent Container.
     * 
     * @return true if this Component should stretch to fill the space 
     *              available in its parent Container, false by default
     */
    shouldStretch : function() {
        return this.$stretches;
    },
    
    /**
     * Specify whether this Component should stretch to fill the size 
     * available in its parent container. If true, this Component will get 
     * sized larger than it would ordinary be, otherwise the layout subsystem 
     * will size it to its normal size.
     * 
     * @param onOff true if this Component should stretch to fill the size
     *              available in its parent Container
     */
    setShouldStretch : function(onOff) {
        this.$stretches = (onOff == true);
    },

    /**
     * Determines if this Container clips to its bounding box when painting. 
     *
     * <b>NOTE:</b> The default value is <i>true</i>, but some subclasses (for 
     * example, pop-up menus) paint elements beyond their basic bounding box.
     * 
     * @return true, if this Container clips its content to its bounding box; 
     *         otherwise, false.
     */
    getClipsContent : function() {
        return this.$clipsContent;
    },
    
    /**
     * Sets whether this Container clips to its bounding box when painting or
     * not.
     *
     * <b>NOTE:</b> The default value is <i>true</i>, but some subclasses (for 
     * example, popup menus) paint elements beyond their basic bounding box.
     * 
     * @param onOff <i>true</i> will cause this Container to clip its paint 
     *              region to its bounding box
     */
    setClipsContent : function(onOff) {
        this.$clipsContent = (onOff == true);
    },
   
    /**
     * Layout and return the desired size of this Component given its
     * current properties. This method should be overridden by subclasses
     * in order to calculate and return a dimension which accommodates the
     * content of the Component. The maximum width and height parameters 
     * are the limits which the Component cannot explicitly exceed. These 
     * values come from the Component's parent Container and layout policy.
     * If the Component has a preferred size set, those dimensions will be
     * passed in as the maximum width and height.
     * 
     * To manually override a Component's sizing behavior, see the 
     * setPreferredSize() and sizeChanged() methods. 
     * 
     * This method combines two essential steps in the layout subsystem,
     * the first to get the desired size of the component, and the second
     * to set the size of the component. The layout subsystem expects a 
     * Component to assume its desired size immediately in doLayout(). 
     * The Component's stretchAndAlign() method will be called subsequently 
     * to inform the Component of the final awarded size. This will generally 
     * equal the size returned from doLayout(), unless the Component is set 
     * to stretch (see the setShouldStretch() method).
     * 
     * Before returning, subclasses should update their inner and outer
     * bounding boxes to reflect the value returned from doLayout(). This
     * will ensure that calling getSize() after the return of doLayout()
     * will return the Component's desired size.
     * 
     * The default implementation of this base method will set the x, y
     * offset of the inner bounding box (using the margin, border, and padding)
     * and the width and height of the outer bounding box to accommodate the
     * full margin, border, and padding. Subclasses should then calculate
     * their inner bounding box width and height, add those values to the
     * outer bounding box width and height, and then return the outer
     * bounding box width and height as the desired size.
     *
     * @param maxWidth the maximum number of pixels wide this Component can 
     *                 occupy.
     * @param maxHeight the maximum number of pixels high this Component can
     *                  occupy.
     * @return the new size of this Component as the 
     *         object &#123 width : #, height: # &#125
     */
    doLayout : function(maxWidth, maxHeight) { 
        // Reset the inner bounds of the component        
        this.$ibounds.x = 0;
        this.$ibounds.y = 0;
        this.$ibounds.w = 0;
        this.$ibounds.h = 0;

        // Reset the outer bounds of the component
        this._contentSize.width = 0;
        this._contentSize.height = 0;

        // Reset the sizeDirty flag
        this.$sizeDirty = false;

        // Set the inner bounds origin
        this.$ibounds.x += (this.$margin.l + this.$padding.l);
        this.$ibounds.y += (this.$margin.t + this.$padding.t);
        
        this._contentSize.width += (this.$ibounds.x + this.$margin.r + this.$padding.r);
        this._contentSize.height += (this.$ibounds.y + this.$margin.b + this.$padding.b);        
        
        if (this.$border != null) {
            // TODO: Allow for variable width borders
            var bw = this.$border.getWidths();
            this.$ibounds.x += bw.left;
            this.$ibounds.y += bw.top;
            this._contentSize.width += (bw.left + bw.right);
            this._contentSize.height += (bw.top + bw.bottom);
        }
        // NOTE that preferred size overrides/ignores the maximum values
        // passed in - to make sure preferred is always honored        
        if (this.$prefSize.w != -1) {
            this.$ibounds.w = this.$prefSize.w - this._contentSize.width;
            if (this.$ibounds.w < 0) {
                this.$ibounds.w = 0;
            }
            this._contentSize.width = this.$prefSize.w;
        }
        if (this.$prefSize.h != -1) {
            this.$ibounds.h = this.$prefSize.h - this._contentSize.height;
            if (this.$ibounds.h < 0) {
                this.$ibounds.h = 0;
            }
            this._contentSize.height = this.$prefSize.h;
        }        
        
        // Before we return, ask the parent TopLevelContainer to track any 
        // of our Images which haven't finished loading yet
        /* TODO
        if (!this.$lazyImagesEnabled) {
            var state = -1;
            var tlc = null;
            var imgs = null;
            var j = 0;
            
            for (var i = 0; i < this.$images.length; i++) {
                if (!this.$images[i]) {
                    continue;
                }
                if (this.$images[i].length) {
                    imgs = this.$images[i];
                } else {
                    imgs = [ this.$images[i] ];                
                }
                for (j = 0; j < imgs.length; j++) {
                    if (imgs[j].state >= cc.ui.Image.PENDING &&
                        imgs[j].state < cc.ui.Image.LOADED) {
                        
                        if (tlc == null) {
                            tlc = this.getTopLevelContainer();
                        }
                        // scr should either be the top level Screen or Widget
                        if (tlc != null) {
                            tlc.trackImage(imgs[j]);
                        }
                    }
                }
            }
        }
        */
        return { "width" : this._contentSize.width, "height" : this._contentSize.height };
    },
    
    /**
     * Method to assign this Component its final awarded size and to align its 
     * content within the space granted.
     * 
     * After the Component has been laid out using its minimum preferred
     * size in the doLayout() method, the stretchAndAlign() method will be
     * called to assign a final size to this Component. The Component may be
     * sized differently than its preferred size used in doLayout(), but
     * regardless the width and height parameters to stretchAndAlign()
     * represent the final dimensions given to this Component. Given those
     * dimensions, the Component should finalize any pending layout tasks
     * such as inner content alignment.
     * 
     * Subclasses should be sure to call the base method to properly set
     * the outer and inner bounding boxes before aligning content.
     * 
     * @param width the final width (in pixels) awarded to this Component by
     *              the layout subsystem
     * @param height the final height (in pixels) awarded to this Component by
     *               the layout subsystem
     */
    stretchAndAlign : function(width, height) {
        if (this._contentSize.width != width) {
            var delta = width - this._contentSize.width;
            this.$ibounds.w += delta;
            this._contentSize.width = width;
        } 
        if (this._contentSize.height != height) {
            var delta = height - this._contentSize.height;
            this.$ibounds.h += delta;
            this._contentSize.height = height;
        }
        
        // Update the background
        if (this.$hasBG)
        {
        	this.$background.setContentSize(cc.size(this.$ibounds.w, this.$ibounds.h));
        	this.$background.setPosition(this.$ibounds.x, this.$ibounds.y);
        	
        	// Ensure the background is behind everything
        	this.reorderChild(this.$background, -1);
        }
    },
    
    /**
     * Experimental density auto-handling function
     */
    scaleForDensity : function(scale) {
        // TODO
    },

    /**
     * Do internal relayout and restretch in the existing bounds.
     * Relayout can be followed by a repaint or not. If repaint is not
     * desired false has to be passed in. If <i>repaint</i> is not passed
     * in Component is repainted by default.
     * @param repaint if true relayout will be followed by a repaint,
     *                if false no repaint will be done
     */
    updateLayout : function(repaint) {
        if (this._contentSize.width > 0 && this._contentSize.height > 0) {
            var w = this._contentSize.width;
            var h = this._contentSize.height;
            this.doLayout(w, h);
            this.stretchAndAlign(w, h);
            if (repaint == true || typeof repaint == 'undefined') {
                this.repaint();
            }
        }
    },
     
    /**
     * Notify the layout subsystem that this Component's size requirements have
     * changed and its parent may need to be updated. Calling this method
     * will asynchronously cause layout to occur and for this Component to be
     * resized within its parent hierarchy.
     */
    sizeChanged : function() {
        this.$sizeDirty = true;
        if (this._parent != null && cc.ui.instaceOf(this._parent, cc.ui.Box)) {
            this._parent.sizeChanged();
        }
    },
    
    /**
     * Get the margin of this Component. The margin represents the empty space
     * (in pixels) around the outer perimeter of the Component.
     *
     * @return the margin of this Component as the 
     *         object &#123; top : #, left : #, bottom : #, right : # &#125;
     */
    getMargin : function() {
        return { "top" : this.$margin.t, "left" : this.$margin.l, 
                 "bottom" : this.$margin.b, "right" : this.$margin.r };
    },
    
    /**
     * Set the margin of this Component. The margin represents the empty space
     * (in pixels) around the perimeter of the Component's content.
     * 
     * This method will not automatically trigger a resize or repaint. If this
     * Component should be re-sized and/or repainted, the application should
     * also call the sizeChanged() and repaint() methods.
     *
     * @param top the top margin (in pixels)
     * @param left the left margin (in pixels)
     * @param bottom the bottom margin (in pixels)
     * @param right the right margin (in pixels)
     */
    setMargin : function(top, left, bottom, right) {
        if (typeof top == 'number' &&
            typeof left == 'number' &&
            typeof bottom == 'number' &&
            typeof right == 'number') {
                    
            this.$margin.t = (top > 0) ? top : 0;
            this.$margin.l = (left > 0) ? left : 0;
            this.$margin.b = (bottom > 0) ? bottom : 0;
            this.$margin.r = (right > 0) ? right : 0;
        } else {
            cc.ui.logW("cc.ui.Component", 
                       "Invalid params to setMargin");
        }
    },
    
    /**
     * Get the current border set for this Component (if any).
     * 
     * @return the cc.ui.Border set for this Component, or null if
     *         none has been set (the default).
     */
    getBorder : function() {
        return this.$border;
    },
    
    /**
     * Set the border to be drawn around this Component. The border is drawn 
     * between the Component's margin and padding. Note that setting a border 
     * does not automatically set or effect any margins the Component may have.
     * 
     * Setting a border will not automatically resize or repaint the Component.
     * For that, see the sizeChanged() and repaint() methods.
     * 
     * Each Component may also have a border to use for its "pressed" state 
     * (see setTouchEnabled()). 
     * 
     * @param border the cc.ui.Border to use to render a border around
     *               this Component, or null.
     */
    setBorder : function(border) {
        if (border == null || cc.ui.instanceOf(border, cc.ui.Border)) {
            this.$border = border;
        } else {
            cc.ui.logW("cc.ui.Component", 
                       "Invalid param to setBorder");
        }
    },
    
    /**
     * Get the padding of this Component. The padding represents the empty space
     * (in pixels) between the border of the Component and its content.
     *
     * @return the padding of this Component as the 
     *         object &#123 top : #, left : #, bottom : #, right : # &#125
     */
    getPadding : function() {
        return { "top" : this.$padding.t, "left" : this.$padding.l,
                 "bottom" : this.$padding.b, "right" : this.$padding.r };
    },
    
    /**
     * Set the padding of this Component. The padding represents the empty space
     * (in pixels) between the border of the Component and its content.
     *
     * Setting the padding will not automatically resize or repaint the 
     * Component. For that, see the sizeChanged() and repaint() methods.
     * 
     * @param top the top padding (in pixels)
     * @param left the left padding (in pixels)
     * @param bottom the bottom padding (in pixels)
     * @param right the right padding (in pixels)
     */
    setPadding : function(top, left, bottom, right) {
        if (typeof top == 'number' &&
            typeof left == 'number' &&
            typeof bottom == 'number' &&
            typeof right == 'number') {
                    
            this.$padding.t = (top > 0) ? top : 0;
            this.$padding.l = (left > 0) ? left : 0;
            this.$padding.b = (bottom > 0) ? bottom : 0;
            this.$padding.r = (right > 0) ? right : 0;
        } else {
            cc.ui.logW("cc.ui.Component", 
                       "Invalid params to setPadding");
        }
    },
         
    /**
     * Get the color value of this Component for the given color type, 
     * if one was set. If no color has been set for a given color type, 
     * this method will return -1. Color values are described by their
     * hexadecimal ARGB string representation, such as "0xFF000000" for
     * opaque black.
     * 
     * Acceptable values for the color type parameter are defined in the
     * cc.ui.Constants class and include: 
     * <ul>
     * <li>COLOR_BG</li>
     * <li>COLOR_BG_HL</li>
     * <li>COLOR_FG</li>
     * <li>COLOR_FG_HL</li>
     * <li>COLOR_FG_SHD</li>
     * <li>COLOR_FG_SHD_HL</li>
     * </ul>
     *
     * @param colorType the constant color identifier as defined in
     *                  cc.ui.Constants.
     * @return the color of this Component for the given color type as a 
     *         cc.Color4B, or null if no value has been set.
     */ 
    getColor : function(colorType) {
        return this.$background.getColor(colorType);
    },
    
    /**
     * Set the color value of this Component for the given color type. 
     * Color values are described by their hexadecimal ARGB string 
     * representation, such as "0xFF000000" for opaque black.
     * 
     * Acceptable values for the color type parameter are defined in the
     * cc.ui.Constants class and include: 
     * <ul>
     * <li>COLOR_BG</li>
     * <li>COLOR_BG_HL</li>
     * <li>COLOR_FG</li>
     * <li>COLOR_FG_HL</li>
     * <li>COLOR_FG_SHD</li>
     * <li>COLOR_FG_SHD_HL</li>
     * </ul>
     *
     * This method does not automatically cause a repaint, so if a
     * repaint is needed after setting the desired color, the application
     * should call the Component's repaint() method.
     * 
     * @param colorType the constant color identifier as defined in
     *                  cc.ui.Constants.
     * @param color the cc.Color4B color value to use
     */ 
    setColor : function(colorType, color) {
    	this.$background.setColor(colorType, color);
    	
    	if (!this.$hasBG)
    	{
    		this.addChild(this.$background, 0);
    		this.$hasBG = true;
    	}
    },

    /**
     * Get the image value of this Component for the given image type, 
     * if one was set. If no image has been set for a given image type, 
     * this method will return null.
     * 
     * Acceptable values for the image type parameter are defined in the
     * cc.ui.Constants class and include: 
     * <ul>
     * <li>IMAGE_BG</li>
     * <li>IMAGE_BG_HL</li>
     * </ul>
     *
     * @param imageType the constant image identifier as defined in
     *                  cc.ui.Constants.
     * @return the image of this Component for the given image type, or null
     *         if no value has been set.
     */ 
    getImage : function(imageType) {
        return (this.$images[imageType]) ? this.$images[imageType] : null;
    },
    
    /**
     * Set the image value of this Component for the given image type. 
     * 
     * Acceptable values for the image type parameter are defined in the
     * cc.ui.Constants class and include: 
     * <ul>
     * <li>IMAGE_BG</li>
     * <li>IMAGE_BG_HL</li>
     * </ul>
     *
     * This method does not automatically cause a repaint, so if a
     * repaint is needed after setting the desired image, the application
     * should call the Component's repaint() method.
     * 
     * @param imageType the constant image identifier as defined in
     *                  cc.ui.Constants.
     * @param image this parameter may be an Image object, an Array of Image
     *              objects, or a string of an image file on disk
     * @param pieces this parameter is the number of pieces comprising the
     *               image, for example for 3 or 9 piece background images.
     *               This parameter is only used when the image parameter is
     *               a string and the image must be loaded from disk.
     * @param ext the optional file extension of the image (".png" by default).
     */ 
    setImage : function(imageType, image, pieces, ext) {
        if (imageType >= cc.ui.Constants.IMAGE_BG &&
                imageType <= cc.ui.Constants.IMAGE_FG_PRESSED) 
        {                
            var img = null; 
            this.$images[imageType] = img;
            // TODO cc.ui.Utilities.loadImage(image, pieces, ext);
            
            if (imageType <= cc.ui.Constants.IMAGE_BG_PRESSED) {
                if (image != null) {
                    this.$hasBG = true;
                } else {
                    if (this._colors[cc.ui.Constants.COLOR_BG] != null
                            || this.$colors[cc.ui.Constants.COLOR_BG_HL] != null
                            || this.$colors[cc.ui.Constants.COLOR_BG_PRESSED] != null
                            || this.$images[cc.ui.Constants.IMAGE_BG] != null
                            || this.$images[cc.ui.Constants.IMAGE_BG_HL] != null
                            || this.$images[cc.ui.Constants.IMAGE_BG_PRESSED] != null ) {
                        this.$hasBG = true;
                    } else {
                        this.$hasBG = false;
                    }
                }
            }            
        }
    },

    /**
     * Determine if this Component is automatically tracking its images. By
     * default, all Components track their images (getLazyImagesEnabled will
     * return false). If this Component is lazy images enabled (see
     * setLazyImagesEnabled()), then it will not automatically  track all images
     * used.
     * 
     * @return false if this Component is tracking its images
     */
    getLazyImagesEnabled : function() {
        return this.$lazyImagesEnabled;
    },
    
    /**
     * Set whether this Component is should automatically track images. By default,
     * all Components track images. If this Component is lazy images enabled 
     * (see getLazyImagesEnabled()), then it will not automatically track it's
     * images.
     * 
     * @param onOff boolean flag false indicating whether this Component should
     *              track its images, true if it should not.
     */
    setLazyImagesEnabled : function(onOff) {
        this.$lazyImagesEnabled = (onOff == true);
    },
    
    
    /**
     * Get the horizontal alignment directive for this Component.
     * Returns either (cc.ui.Constants.)ALGN_LEFT, ALGN_CENTER,
     * ALGN_RIGHT. The default is ALGN_LEFT.
     *
     * @return the horizontal alignment directive for the component
     */ 
    getHorizAlign : function() {
        return this.$halign;
    },
    
    /**
     * Set the horizontal alignment directive for this Component.
     * The value must be one of (cc.ui.Constants.)ALGN_LEFT,
     * ALGN_CENTER, or ALGN_RIGHT.
     * 
     * This method does not automatically cause a repaint, so if a
     * repaint is needed after setting the alignment, the application
     * should call the Component's repaint() method.
     *
     * @param align the horizontal alignment value
     */
    setHorizAlign : function(align) {
        switch (align) {
            case cc.ui.Constants.ALGN_LEFT:
            case cc.ui.Constants.ALGN_CENTER:
            case cc.ui.Constants.ALGN_RIGHT:
                this.$halign = align;
                break;
            default:
                cc.ui.logW("cc.ui",
                           "Invalid param to setHorizAlign: " + align);
                break;
        }
    },
    
    /**
     * Get the vertical alignment directive for this Component.
     * Returns either (cc.ui.Constants.)ALGN_TOP, ALGN_MIDDLE,
     * ALGN_BASELINE. ALGN_TOP is the default.
     *
     * @return the vertical alignment directive for the component
     */ 
    getVertAlign : function() {
        return this.$valign;
    },
    
    /**
     * Set the vertical alignment directive for this Component.
     * The value must be one of (cc.ui.Constants.)ALGN_TOP,
     * ALGN_MIDDLE, ALGN_BASELINE, or ALGN_BOTTOM.
     *
     * This method does not automatically cause a repaint, so if a
     * repaint is needed after setting the alignment, the application
     * should call the Component's repaint() method.
     * 
     * @param align the vertical alignment value
     */
    setVertAlign : function(align) {
        switch (align) {
            case cc.ui.Constants.ALGN_TOP:
            case cc.ui.Constants.ALGN_MIDDLE:
            case cc.ui.Constants.ALGN_BASELINE:
            case cc.ui.Constants.ALGN_BOTTOM:
                this.$valign = align;
                break;
            default:
                cc.ui.logW("cc.ui",
                           "Invalid param to setVertAlign: " + align);
        }
    },
    
    /**
     * Determine if the given point lies within this Component's bounds.
     * Note that the point should already be in the coordinate space of this 
     * Component.
     * 
     * @param x the x-coordinate of the point
     * @param y the y-coordinate of the point
     * @return true if the point lies within this Component's bounding box 
     */
    containsPoint : function(x, y) {
        return ((x >= 0 && x < this._contentSize.width) && 
                (y >= 0 && y < this._contentSize.height));
    },
    
    /**
     * Determine if this Component is an ancestor of the given Component.
     * By default, this method always returns false, as components are
     * considered leaves in the tree and have no descendants. It is here as
     * a convenience to help avoid the common case of testing if a component
     * is a container to see if it is also the ancestor of a component.
     * 
     * @param component the component to search within this component for.
     * 
     * @return false by default  
     */
    isAncestor : function(component) {
        return false;
    },

    /**
     * DEPRECATED 
     * <br>
     * This function is no longer used to draw the background -- instead,
     * the class <a href="./cc.ui.Background.html">cc.ui.Background</a> 
     * is utilized.
     * <br> <br>
     * Paint the background of this Component. By default this method will
     * first look for the appropriate background image to draw. If no
     * background images have been set, the Component's appropriate
     * background color will be used to fill the background. This method
     * will correctly draw the highlighted state of the background if this
     * Component currently has the input focus.
     *
     * @param context the context to draw the background of the Component to
     */
    drawBackground : function(context) {        
        /*
        var bgImage = null;
        var bgColor = null;
        if (this.$ownsFocus) {
            bgImage = this.$images[cc.ui.Constants.IMAGE_BG_HL];
            bgColor = this.$colors[cc.ui.Constants.COLOR_BG_HL];
            if (bgImage == null) {
                bgImage = this.$images[cc.ui.Constants.IMAGE_BG];
            }
            if (bgColor == null) {
                bgColor = this.$colors[cc.ui.Constants.COLOR_BG];
            }
        } else {
            bgImage = this.$images[cc.ui.Constants.IMAGE_BG];
            bgColor = this.$colors[cc.ui.Constants.COLOR_BG];
        }
        
        if (this.$pressed && this.$images[cc.ui.Constants.IMAGE_BG_PRESSED]) {
            bgImage = this.$images[cc.ui.Constants.IMAGE_BG_PRESSED];
        }
        if (this.$pressed && this.$colors[cc.ui.Constants.COLOR_BG_PRESSED]) {
            bgColor = this.$colors[cc.ui.Constants.COLOR_BG_PRESSED];
        }
        if (bgImage != null) {
            // TODO: Image background, Sprite?
        } else if (bgColor != null) {
            context.fillStyle = "rgba(" + bgColor.r + "," + bgColor.g + ","
                                        + bgColor.b + "," + bgColor.a + ")";

            // TODO: Move the vertex setting into the stretchAndAlign method?

            var x1y1 = cc.Vertex2(this.$ibounds.x - this.$padding.l, this.$ibounds.y - this.$padding.b);
            var x1y2 = cc.Vertex2(x1y1.x, x1y1.y + this.$ibounds.h + this.$padding.t);
            var x2y2 = cc.Vertex2(x1y1.x + this.$ibounds.w + this.$padding.r, x1y2.y);
            var x2y1 = cc.Vertex2(x2y2.x, x1y1.y);

            if (this._tag == "TestNode") {
                var p = this.getPosition();
                console.log("CCUIComponent, drawing testnode: [" + x1y1.x + "," + x1y1.y + "] [" + x1y2.x + "," + x1y2.y + "] [" + x2y2.x + "," + x2y2.y + "] [" + x2y1.x + "," + x2y1.y + "]");
                console.log("CCUIComponent, at position: " + p.x + "," + p.y);
            }
            cc.drawingUtil.drawPoly([ x1y1, x1y2, x2y2, x2y1 ], 4, false, true);

            /*
            surface.renderer2D.setColor(bgColor);
            surface.renderer2D.fillRect(
                this.ibounds.x - this.padding.l, 
                this.ibounds.y - this.padding.t, 
                this.ibounds.w + this.padding.l + this.padding.r, 
                this.ibounds.h + this.padding.t + this.padding.b, 
                bgColor); 
            * /  
        }
        */
    },
    
    /**
     * Paint the content of this Component. This method should be overridden by
     * subclasses in order to paint the content of the Component. Note that
     * the content of this Component should correctly allow for the margin,
     * border, and padding. The surface parameter will be in the original
     * coordinate space of the Component but the clip will be set to the
     * compontent's inner content area by default.
     *
     * @param context the context to draw the (foreground) content of the Component to
     */
    drawContent : function(context) {
    },
    
    /**
     * Paint an overlay on this Component. This method should be overridden by
     * subclasses in order to paint an overlay on this Component after its
     * normal paint routine has completed. For example, a tooltip or fade
     * over of some sort. The Component's bounding rectangle will still be
     * in effect as the clip.
     * 
     * @param ctx the context to draw the overlay of the Component to
     */   
    drawOverlay : function(ctx) {     
    },
    
    /**
     * Draw this component. By default, the Component.paint() routine
     * calls the paintBackground() function to paint the background, then
     * paints the Border (if there is one), then calls the
     * paintContent() function which subclasses should override. Lastly,
     * the paintOverlay() method is called. The only method which will have
     * a clip in place is the paintContent() method, which will be clipped
     * to the content area of this Component. Note that none of the methods
     * translate the coordinate space at all.
     *
     * @param ctx the context to draw the Component to
     */
    draw : function(ctx) {        
        var context = ctx || cc.renderContext;
        //context.save();

        if (context != null && this._visible) {
        	this.$background.setFocusAndPressed(this.$ownsFocus, this.$pressed);
            
            try {
                if (this.$border != null) {
                    this.$border.draw(
                        this.$margin.l, 
                        this.$margin.t,
                        this._contentSize.width - this.$margin.l - this.$margin.r,
                        this._contentSize.height - this.$margin.t - this.$margin.b,
                        context);
                    
                }       
            } catch (err) {
                cc.ui.logE("cc.ui", 
                           "Component.paint.border error: " + err);
            }

            // Make a copy of the 'clipsContent' state in case it 
            // changes during the call to the application's paintContent()
            var clipped = (this.$clipsContent == true);
            if (clipped) {
                try  {
                    // TODO
                    
                    //pushClip(this.$ibounds.x, this.$ibounds.y, 
                    //         this.$ibounds.w, this.$ibounds.h);
                    
                } catch (err) { 
                    cc.ui.logE("cc.ui",
                               "Component.paint.pushClip error: " + err);
                }
            }

            try {
                this.drawContent(context);
            } catch (err) {
                cc.ui.logE("cc.ui", 
                           "Component.paint.content error: " + err);
            }
            
            if (clipped) {
                // TODO
                //popClip();
            }

            if (this.$hasOverlay) {
                try {
                    this.drawOverlay(surface);
                } catch (err) {
                    cc.ui.logE("cc.ui", 
                               "Component.paint.overlay error: " + err);
                }
            }
            this.$isDirty = false;
        }

        //context.restore();
    },

    /**
     * Request that an area of this Component be repainted. The parameters
     * to this method should be in the Component's own coordinate space
     * and define the region of the Component to be repainted. If no
     * parameters are given, then the entire Component is repainted (the
     * same as calling repaint(0, 0, [full width], [full height]).
     *
     * Note that this is an asynchronous call, and any repaint requests will 
     * be fulfilled after any application calls have returned.
     *
     * @param x the x coordinate of the origin of the region to be repainted
     * @param y the y coordinate of the origin of the region to be repainted
     * @param w the width of the region to be repainted
     * @param h the height of the region to be repainted
     */
    repaint : function(x, y, w, h) {
        this.$isDirty = true;    
        // We only sanitize the parameters if this Component is set to
        // clip its content
        if (this.$clipsContent) {
            x = (x && x >= 0 && x < this._contentSize.width) ? x : 0;
            y = (y && y >= 0 && y < this._contentSize.height) ? y : 0;
            w = (w && w > 0 && w < this._contentSize.width) ? w : this._contentSize.width;
            h = (h && h > 0 && h < this._contentSize.height) ? h : this._contentSize.height;
        }
        
        // Request the container repaint a region (translated into
        // the container's coordinate space)

        // TODO refactor away $container to be _parent
        if (this.$container != null) {
            this.$container.repaint(
                this._position.x + x, this._position.y + y, w, h);
        }       
    },
    
    // EVENT HANDLING
    
    /**
     * Called on this Component to process a key press. If this Component
     * processed the key and further processing should stop, this method should
     * return true. If this Component did not process the key press, or if
     * further processing should continue, this method should return false
     * (returns false by default). This Component will only receive key press
     * events if it is focusable and currently has the input focus.
     *
     * @param keyCode the key identifier as defined by the Phone object.
     * @return true if this Component fully processed the key event, false
     *         otherwise
     */
    keyPress : function(keyCode) {
        this.notifyListeners("keyPress", { "keyCode" : keyCode } );
        if (this.$touchEnabled && keyCode == cc.Device.KEY_SELECT) {
            this.$pressed = true;
            this.repaint();
        }
        this.$sawKey = keyCode;
        return false;
    },
    
    /**
     * Called on this Component to process a key release. If this Component
     * processed the key and further processing should stop, this method should
     * return true. If this Component did not process the key release, or if
     * further processing should continue, this method should return false
     * (returns false by default). This Component will only receive key release
     * events if it is focusable and currently has the input focus.
     *
     * @param keyCode the key identifier as defined by the Phone object.
     * @return true if this Component fully processed the key event, false
     *         otherwise
     */
    keyRelease : function(keyCode) {
        this.notifyListeners("keyRelease", { "keyCode" : keyCode } );
        if (this.$touchEnabled && this.$pressed) {
            this.$pressed = false;
            this.notifyListeners("pressed");
            this.repaint();
        }           
        if (this.$sawKey == keyCode) {
            this.notifyListeners("keyFired", { "keyCode" : keyCode } );            
        }
        this.$sawKey = -1;
        return false;
    },
    
    /**
     * Called on this Component to process a long key press (otherwise known
     * as a press-hold). If this Component processed the key and further 
     * processing should stop, this method should return true. If this 
     * Component did not process the long key press, or if further processing
     * should continue, this method should return false (returns false by 
     * default). This Component will only receive long key press events if it 
     * is focusable and currently has the input focus.
     *
     * @param keyCode the key identifier as defined by the Phone object.
     * @return true if this Component fully processed the key event, false
     *         otherwise
     */
    keyLongPress : function(keyCode) {
        this.notifyListeners("keyLongPress", { "keyCode" : keyCode } );
        return false;
    },
    
    /**
     * Called on this Component to process a pen press. If this Component
     * processed the pen press and further processing should stop, this 
     * method should return true. If this Component did not process the 
     * pen press, or if further processing should continue, this method 
     * should return false. This Component will receive pen press events 
     * even if it is not focusable if the pen event occurred within its 
     * bounds. By default, this method returns false, even if the Component
     * has touch support enabled (see setTouchEnabled()).
     *
     * @param x the x coordinate of the pen press
     * @param y the y coordinate of the pen press
     * @return true if this Component fully processed pen press, false
     *         otherwise
     */
    penPress : function(x, y) {
        // Note that penDown info needs to be cached right away because
        // penPress results in focus request and changeFocus can be using
        // penDown info
        this.$penDown = {"x" : x, "y" : y};
        this.$penDownTime = cc.Device.getProperty(cc.Device.PROP_TICKS);
        this.notifyListeners("penPress", { "x" : x, "y" : y } );

        if (this.$touchEnabled) {
            // TODO: add some application-level controls about using haptics
            // rather than automatically using them
            cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_BASIC);
            var tlc = this.getTopLevelContainer();
            if (tlc != null) {
                var fm = tlc.getFocusManager();
                fm.$pressItem = this;
            }
            this.$pressed = true;
            if (!this.$focusable || this.$ownsFocus) {
                // A repaint will be generated automatically by the FocusManager
                this.repaint();
            }
        }
        
        if (this.$focusable) {
            this.requestFocus();
        }
        return false;
    },
    
    /**
     * Called on this Component to process a pen drag. If this Component
     * processed the pen drag and further processing should stop, this 
     * method should return true. If this Component did not process the 
     * pen drag, or if further processing should continue, this method 
     * should return false. This Component will receive pen drag events 
     * even if it is not focusable if the pen drag occurred within its 
     * bounds. By default, this method returns false, even if the Component
     * has touch support enabled (see setTouchEnabled()).     
     *
     * @param x the x coordinate of the pen drag
     * @param y the y coordinate of the pen drag
     * @return true if this Component fully processed pen drag, false
     *         otherwise
     */
    penDrag : function(x, y) {
        this.notifyListeners("penDrag", { "x" : x, "y" : y } ); 

        if (this.$swipeEnabled && this.$penDown != null) {
            var delta = { "x" : x - this.$penDown.x, "y" : y - this.$penDown.y };
            var absDelta = { "x" : Math.abs(delta.x), "y" : Math.abs(delta.y) };
            var ratio = { "x" : Math.round(0.5 * absDelta.x), "y" : Math.round(0.5 * absDelta.y) };
            if (absDelta.x > 40 && absDelta.y < ratio.x) {
                swipe = true;
                this.notifyListeners("swipeEvent", 
                   {"dir"      : (delta.x > 0 ? cc.ui.Constants.TRVS_RIGHT :
                                     cc.ui.Constants.TRVS_LEFT), 
                    "startX"   : this.$penDown.x, 
                    "startY"   : this.$penDown.y,
                    "endX"     : x, 
                    "endY"     : y,
                    "deltaX"   : delta.x, 
                    "deltaY"   : delta.y,
                    "duration" : (cc.Device.getProperty(cc.Device.PROP_TICKS) - this.$penDownTime)});
                                
                this.$penDown = null;
                this.$pressed = false;
                cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_BASIC);
            } else if (absDelta.y > 40 && absDelta.x < ratio.y) {
                swipe = true;
                this.notifyListeners("swipeEvent", 
                   {"dir"      : (delta.y > 0 ? cc.ui.Constants.TRVS_DOWN :
                                     cc.ui.Constants.TRVS_UP), 
                    "startX"   : this.penDown.x, 
                    "startY"   : this.penDown.y,
                    "endX"     : x, 
                    "endY"     : y,
                    "deltaX"   : delta.x, 
                    "deltaY" : delta.y,
                    "duration" : (cc.Device.getProperty(cc.Device.PROP_TICKS) - this.penDownTime)});
                this.penDown = null;
                this.pressed = false;
                cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_BASIC);
            } else {
                cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_SENSITIVE);
            }
        }

        return false;
    },
    
    /**
     * Called on this Component to process a pen release. If this Component
     * processed the pen release and further processing should stop, this 
     * method should return true. If this Component did not process the 
     * pen release, or if further processing should continue, this method 
     * should return false. This Component will receive pen release events 
     * even if it is not focusable if the pen release occurred within its 
     * bounds. By default, this method returns false, even if the Component
     * has touch support enabled (see setTouchEnabled()).     
     *
     * @param x the x coordinate of the pen release
     * @param y the y coordinate of the pen release
     * @return true if this Component fully processed pen release, false
     *         otherwise
     */
    penRelease : function(x, y) {
        this.notifyListeners("penRelease", { "x" : x, "y" : y } );
        
        if (this.$touchEnabled && this.$pressed) {
            this.$pressed = false;
            cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_BASIC);
            this.notifyListeners("pressed", { "x" : x, "y" : y });
            this.repaint();
        }
                
        this.$penDown = null;
        this.$penDownTime = 0;
        
        return false;
    },

    /**
     * Called on this Component to process a long pen press. If this Component
     * processed the long pen press and further processing should stop, this 
     * method should return true. If this Component did not process the 
     * long pen press, or if further processing should continue, this method 
     * should return false. This Component will receive pen long press events
     * if it is not focusable if the pen long press occurred within its bounds.
     * By default, this method returns false, even if the Component
     * has touch support enabled (see setTouchEnabled()).     
     *
     * @param x the x coordinate of the long pen press
     * @param y the y coordinate of the long pen press
     * @return true if this Component fully processed long pen press, false
     *         otherwise
     */
    penLongPress : function(x, y) {
        cc.Device.touchFeedback(cc.Device.TOUCH_FEEDBACK_BASIC);
        this.notifyListeners("penLongPress", { "x" : x, "y" : y } );
        return false;
    },
    
    
    /**
     * Called on this Component to process text input. This Component
     * should accept the text as input and render accordingly. This method
     * is typically associated with input methods on the device, such as
     * predictive text, multi-tap, etc. If this Component did not process the 
     * text input, or if further processing should continue, this method 
     * should return false (returns false by default). This Component will
     * only receive text input events if it is focusable and currently has
     * the input focus.
     *
     * @param text the textual input to process
     * @param replace if true all Component's content should be replaced with
     *        the passed in text; false otherwise
     * @return true if this Component fully processed the text input, false
     *         otherwise
     */
    textInput : function(text, replace) {
        this.notifyListeners("textInput", { "text" : text , "replace" : replace} );
        return false;
    },
    
    /**
     * Determine if this Component is enabled to receive swipe events.
     * By default, all Components do not have the ability to receive swipe events. 
     * If this Component is enabled (see setSwipeEnabled()), then it will 
     * automatically process swipe events and generate "swipeEvent" events.
     * 
     * @return true if this Component is enabled to receive swipe events
     */
    getSwipeEnabled : function() {
        return this.$swipeEnabled;
    },
    
    /**
     * Set whether this Component is enabled to receive swipe events. By default,
     * all Components do not get swipe events. If this Component
     * is enabled to receive swipe events (see getSwipeEnabled()), then it will 
     * automatically process swipe events and generate "swipeEvent" event.
     * 
     * @param onOff flag indicating whether this Component should get
     *              swipe events
     */
    setSwipeEnabled : function(onOff) {
        this.$swipeEnabled = (onOff == true);
    },
    
    /**
     * Add a listener to this Component for the given event 
     * (or set of events). When an event of the given type occurs on this
     * Component, the listener will be notified through its notify() method.
     * The event parameter may be either a single string representing
     * the event type, or an Array of strings representing multiple
     * event types for which the given listener should be registered.
     * 
     * The listener must either be of the type cc.ui.EventListener or
     * a function.
     * 
     * @param event the event (or set of events) for which to register
     *              the listener
     * @param listener the listener to register for the given event or
     *                 set of events
     */
    addListener : function(event, listener) {
        if (typeof event == 'string') {
            event = new Array(event);
        }
        
        // Never add the same listener twice for the same event
        this.removeListener(event, listener);
        
        // NOTE: this.listeners is an "associative array"
        // which stores an array of listeners under each
        // event name (kept as a property on this.listeners)
        if (event.length) {
            for (var i = 0; i < event.length; i++) {
                if (!event[i]) {
                    continue;
                }
                if (!this.$listeners[event[i]]) {
                    this.$listeners[event[i]] = new Array();
                }
                this.$listeners[event[i]].push(listener);
            }
        }           
    },
        
    /**
     * Remove the given listener for the given event (or set of events).
     * The event parameter may be either a single string representing
     * the event type, or an Array of strings representing multiple
     * event types for which the given listener should be unregistered.
     * 
     * @param event the event (or set of events) for which to unregister
     *              the listener
     * @param listener the listener to unregister for the given event or
     *                 set of events
     */
    removeListener : function(event, listener) {
        if (typeof event == 'string') {
            event = new Array(event);
        }
        
        if (event.length) {
            var queue = null;
            for (var i = 0; i < event.length; i++) {    
                if (this.$listeners[event[i]]) {
                    queue = this.$listeners[event[i]];
                    for (var j = 0; j < queue.length; j++) {
                        if (queue[j] === listener) {
                            queue.splice(j, 1);
                            break;
                        }
                    }
                }
            }
        }       
    },
    
    /**
     * Used to notify all of this Component's registered listeners
     * about the occurrence of a specific event. The event is
     * identified by a string, and the details of that event is
     * an object containing properties specific to that event.
     * 
     * Every details object will have a 'src' property which is set
     * to the Component which generated it.
     * 
     * @param event a string identifying the type of event
     * @param details an Object containing the specific properties
     *                of the event
     */
    notifyListeners : function(event, details) {
        var listeners = this.$listeners[event];
        if (listeners) {
            // Automatically set the source object for all events
            if (!details) {
                details = new Object();
            }
            details.src = this;
            for (var i = 0; i < listeners.length; i++) {
                try {
                    if (!listeners[i]) {
                        continue;
                    } else if (typeof listeners[i] == 'function') {
                        listeners[i](event, details);
                    } else if (listeners[i].eventNotify) {
                        listeners[i].eventNotify(event, details);
                    }
                } catch (err) {
                    cc.ui.logE("cc.ui", 
                               "Component.notifyListeners: Error " +
                               "notifying listener on event: " + event +
                               " Error: " + err);
                }
            }
        }
    },

});
